[{"path":"/2024/06/30/icoding-other/","content":"Icoding其他题解——数据结构 我只能说剩下的题都挺抽象，不是很愿意花时间为它们写题解了，因此将答案都放在这里，需要的自取吧。 字符串块链串逆天题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677bool blstr_substr(BLString src, int pos, int len, BLString *sub) &#123; if(pos &lt; 0 || pos &gt;= src.len || len &lt;= 0 || sub == NULL) return false; sub-&gt;head = (Block*)malloc(sizeof(Block)); if(sub-&gt;head == NULL) return false; Block* sub_ptr = sub-&gt;head; Block* src_ptr = src.head; int char_index = 0; int src_block_index = 0; int sub_block_index = 0; while(char_index &lt; pos + len &amp;&amp; src_ptr != NULL &amp;&amp; src_ptr-&gt;ch[src_block_index] != BLS_BLANK) &#123; if (char_index &lt; pos) &#123; if(src_block_index &lt; BLOCK_SIZE - 1) src_block_index++; else &#123; src_ptr = src_ptr-&gt;next; src_block_index = 0; &#125; char_index++; &#125; else &#123; sub_ptr-&gt;ch[sub_block_index] = src_ptr-&gt;ch[src_block_index]; if(src_block_index &lt; BLOCK_SIZE - 1) src_block_index++; else &#123; src_ptr = src_ptr-&gt;next; src_block_index = 0; &#125; if(sub_block_index &lt; BLOCK_SIZE - 1) sub_block_index++; else &#123; sub_ptr-&gt;next = (Block*)malloc(sizeof(Block)); sub_ptr = sub_ptr-&gt;next; sub_ptr-&gt;next = NULL; sub_block_index = 0; &#125; char_index ++; sub-&gt;len ++; &#125; &#125; if(sub_block_index != 0) &#123; sub-&gt;tail = sub_ptr; while(sub_block_index &lt; BLOCK_SIZE) &#123; sub_ptr-&gt;ch[sub_block_index] = BLS_BLANK; sub_block_index++; &#125; &#125; else &#123; sub-&gt;tail = sub-&gt;head; while(sub-&gt;tail-&gt;next != sub_ptr) &#123; sub-&gt;tail = sub-&gt;tail-&gt;next; if(sub-&gt;tail == NULL) return false; &#125; sub-&gt;tail-&gt;next = NULL; free(sub_ptr); &#125; return true;&#125; 串替换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667int pos_len(const char *str, int pos)&#123; int num = 0; for(int i = pos; str[i] != &#x27;\\0&#x27;; i++) num++; return num;&#125;int str_replace(const char *in, char *out, int outlen, const char *oldstr, const char *newstr)&#123; int replace_count = 0; int out_index = 0; int newstr_len = pos_len(newstr, 0); for(int i = 0; i &lt; outlen;i++) out[i] = &#x27;\\0&#x27;; int in_index = 0; while(in_index &lt; outlen) &#123; int oldstr_index = 0; while(oldstr[oldstr_index] != &#x27;\\0&#x27;) &#123; if(oldstr[oldstr_index] != in[in_index]) &#123; in_index = in_index - oldstr_index + 1; break; &#125; in_index++; oldstr_index++; &#125; if(oldstr[oldstr_index] != &#x27;\\0&#x27;) &#123; out[out_index] = in[in_index - 1]; out_index++; &#125; else &#123; int current_len = pos_len(out, 0) + pos_len(in, in_index) + newstr_len; if (current_len &lt; outlen) &#123; for(int i = 0; newstr[i] != &#x27;\\0&#x27;; i++) &#123; out[out_index] = newstr[i]; out_index++; &#125; replace_count++; &#125; else &#123; while(oldstr_index != 0) &#123; out[out_index] = in[in_index - oldstr_index]; out_index++; oldstr_index--; &#125; &#125; &#125; if(in[in_index] == &#x27;\\0&#x27;) &#123; out_index++; break; &#125; &#125; return replace_count;&#125; 串比较还算比较有人性。 1234567891011121314151617181920212223242526272829303132333435int str_compare(const char* ptr1, const char* ptr2)&#123; int cmp_value = 0; int i = 0; while(1) &#123; if(ptr1[i] == &#x27;\\0&#x27; &amp;&amp; ptr2[i] == &#x27;\\0&#x27;) break; if(ptr1[i] == &#x27;\\0&#x27; &amp;&amp; ptr2[i] != &#x27;\\0&#x27;) &#123; cmp_value = -ptr2[i]; break; &#125; if(ptr1[i] != &#x27;\\0&#x27; &amp;&amp; ptr2[i] == &#x27;\\0&#x27;) &#123; cmp_value = ptr1[i]; break; &#125; if(ptr1[i] != ptr2[i]) &#123; if(ptr1[i] + &#x27;a&#x27; - &#x27;A&#x27; == ptr2[i] || ptr2[i] + &#x27;a&#x27; - &#x27;A&#x27; == ptr1[i]); else &#123; cmp_value = ptr1[i] - ptr2[i]; break; &#125; &#125; i++; &#125; return cmp_value;&#125; 图的存储邻接矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354bool matrix_insert_vertex(MatrixGraph *G, VertexType v)&#123; if(G == NULL) return false; if(G-&gt;vexnum == MAX_VERTEX_NUM) return false; int new_vex_index = matrix_locate_vertex(G, v); if(new_vex_index != -1) return false; G-&gt;vexnum++; new_vex_index = G-&gt;vexnum - 1; G-&gt;vertex[new_vex_index] = v; for(int i = 0; i &lt; MAX_VERTEX_NUM; i++) &#123; G-&gt;arcs[i][new_vex_index] = 0; G-&gt;arcs[new_vex_index][i] = 0; &#125; return true;&#125;bool matrix_insert_arc(MatrixGraph *G, VertexType v, VertexType w)&#123; if(G == NULL) return false; int vex_index_v = matrix_locate_vertex(G, v); int vex_index_w = matrix_locate_vertex(G, w); if(vex_index_v == -1 || vex_index_w == -1) return false; if(G-&gt;type == DG) &#123; if(G-&gt;arcs[vex_index_v][vex_index_w] == -1) G-&gt;arcs[vex_index_v][vex_index_w] = 1; else return false; &#125; else &#123; if(G-&gt;arcs[vex_index_v][vex_index_w] == -1) G-&gt;arcs[vex_index_v][vex_index_w] = 1; else return false; if(G-&gt;arcs[vex_index_w][vex_index_v] == -1) G-&gt;arcs[vex_index_w][vex_index_v] = 1; else return false; &#125; G-&gt;arcnum++; return true;&#125; 邻接表11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374bool insert_vertex(ListGraph *G, VertexType v)&#123; if(G == NULL) return false; int new_ver_index = locate_vertex(G, v); if(new_ver_index != -1) return false; G-&gt;vexnum++; new_ver_index = G-&gt;vexnum - 1; G-&gt;vertex[new_ver_index].data = v; G-&gt;vertex[new_ver_index].firstarc = NULL; return true;&#125;bool insert_arc(ListGraph *G, VertexType v, VertexType w)&#123; if(G == NULL) return false; int v_index = locate_vertex(G, v); int w_index = locate_vertex(G, w); if(v_index == -1 || w_index == -1) return false; ArcNode *curr = G-&gt;vertex[v_index].firstarc; ArcNode *prev = curr; while(curr != NULL) &#123; if(curr-&gt;adjvex == w_index) return false; prev = curr; curr = curr-&gt;nextarc; &#125; ArcNode* temp = (ArcNode*)malloc(sizeof(ArcNode)); if(temp == NULL) return false; temp-&gt;adjvex = w_index; temp-&gt;nextarc = NULL; if(prev == curr) G-&gt;vertex[v_index].firstarc = temp; else prev-&gt;nextarc = temp; if(G-&gt;type == UDG) &#123; ArcNode *curr1 = G-&gt;vertex[w_index].firstarc; ArcNode *prev1 = curr1; while(curr1 != NULL) &#123; if(curr1-&gt;adjvex == v_index) return false; prev1 = curr1; curr1 = curr1-&gt;nextarc; &#125; ArcNode *temp1 = (ArcNode*)malloc(sizeof(ArcNode)); if(temp1 == NULL) return false; temp1-&gt;adjvex = v_index; temp1-&gt;nextarc = NULL; if(curr1 == prev1) G-&gt;vertex[w_index].firstarc = temp1; else prev1-&gt;nextarc = temp1; &#125; G-&gt;arcnum ++; return true;&#125; 邻接表212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061bool del_vertex(ListGraph *G, VertexType v)&#123; if(G == NULL) return false; int v_index = locate_vertex(G, v); if(v_index == -1) return false; ArcNode *curr = G-&gt;vertex[v_index].firstarc; ArcNode *prev = curr; while(curr != NULL) &#123; prev = curr; curr = curr-&gt;nextarc; G-&gt;vertex[v_index].firstarc = curr; free(prev); G-&gt;arcnum--; &#125; for(int i = v_index; i &lt; G-&gt;vexnum; i++) G-&gt;vertex[i] = G-&gt;vertex[i + 1]; G-&gt;vexnum--; ArcNode *cur = NULL; for(int i = 0; i &lt; G-&gt;vexnum; i++) &#123; cur = G-&gt;vertex[i].firstarc; while(cur != NULL) &#123; if(cur-&gt;adjvex &gt; v_index) &#123; cur-&gt;adjvex--; cur = cur-&gt;nextarc; &#125; else if(cur-&gt;adjvex == v_index) &#123; ArcNode *del = cur; if(G-&gt;vertex[i].firstarc == cur) &#123; G-&gt;vertex[i].firstarc = cur-&gt;nextarc; cur = cur-&gt;nextarc; free(del); &#125; else &#123; ArcNode *pre = G-&gt;vertex[i].firstarc; while(pre-&gt;nextarc != cur) pre = pre-&gt;nextarc; pre-&gt;nextarc = cur-&gt;nextarc; cur = cur-&gt;nextarc; free(del); &#125; G-&gt;arcnum--; &#125; else cur = cur-&gt;nextarc; &#125; &#125; return true;&#125; 数组广义表十字链表12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273int init_cross_list(PCrossList L, const ElemType *A, int m,int n)&#123; L-&gt;rows = m; L-&gt;cols = n; L-&gt;nums = 0; L-&gt;rowhead = (OLink*)malloc(sizeof(OLink) * (m + 1)); if(L-&gt;rowhead == NULL) exit(0); for(int i = 0; i &lt; m + 1; i++) L-&gt;rowhead[i] = NULL; L-&gt;colhead = (OLink*)malloc(sizeof(OLink) * (n + 1)); if(L-&gt;colhead == NULL) exit(0); for(int i = 0; i &lt; n + 1; i++) L-&gt;colhead[i] = NULL; OLink pRow = NULL; OLink pCol = NULL; for(int i = 0; i &lt; m * n ; i ++) &#123; if(A[i] == 0) continue; int rrow = i / n + 1; int ccol = i % n + 1; OLink curr = (OLink)malloc(sizeof(OLNode)); if (curr == NULL) exit(0); curr-&gt;down = NULL; curr-&gt;right = NULL; curr-&gt;row = i / n + 1; curr-&gt;col = i % n + 1; curr-&gt;value = A[i]; L-&gt;nums++; if(i % n == 0) pRow = L-&gt;rowhead[rrow]; if(L-&gt;rowhead[rrow] == NULL) &#123; L-&gt;rowhead[rrow] = curr; curr-&gt;right = NULL; pRow = curr; &#125; else &#123; while(pRow-&gt;right != NULL) pRow = pRow-&gt;right; pRow-&gt;right = curr; curr-&gt;right = NULL; pRow = curr; &#125; pCol = L-&gt;colhead[ccol]; if(L-&gt;colhead[ccol] == NULL) &#123; L-&gt;colhead[ccol] = curr; curr-&gt;down = NULL; pCol = curr; &#125; else &#123; while(pCol-&gt;down != NULL) pCol = pCol-&gt;down; pCol-&gt;down = curr; curr-&gt;down = NULL; pCol = curr; &#125; &#125; return L-&gt;nums;&#125; 矩阵加法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283bool add_matrix(const TSMatrix *pM, const TSMatrix *pN, TSMatrix *pQ)&#123; if(pM-&gt;m != pN-&gt;m || pM-&gt;n != pN-&gt;n) return false; pQ-&gt;m = pM-&gt;m; pQ-&gt;n = pM-&gt;n; int DataPosition = 0; int m = 0; int n = 0; int judge = -1; while(1) &#123; if(m == pM-&gt;len &amp;&amp; n == pN-&gt;len) break; if(m == pM-&gt;len) judge = 1; else if(n == pN-&gt;len) judge = 2; else &#123; if(pN-&gt;data[n].i &lt; pM-&gt;data[m].i) judge = 1; else if(pN-&gt;data[n].i == pM-&gt;data[m].i) &#123; if(pN-&gt;data[n].j &lt; pM-&gt;data[m].j) judge = 1; else if (pN-&gt;data[n].j &gt; pM-&gt;data[m].j) judge = 2; else judge = 0; &#125; else judge = 2; &#125; switch (judge) &#123; case 1: pQ-&gt;data[DataPosition].i = pN-&gt;data[n].i; pQ-&gt;data[DataPosition].j = pN-&gt;data[n].j; pQ-&gt;data[DataPosition].e = pN-&gt;data[n].e; n++; DataPosition++; break; case 2: pQ-&gt;data[DataPosition].i = pM-&gt;data[m].i; pQ-&gt;data[DataPosition].j = pM-&gt;data[m].j; pQ-&gt;data[DataPosition].e = pM-&gt;data[m].e; m++; DataPosition++; break; case 0: pQ-&gt;data[DataPosition].i = pM-&gt;data[m].i; pQ-&gt;data[DataPosition].j = pM-&gt;data[m].j; pQ-&gt;data[DataPosition].e = pM-&gt;data[m].e + pN-&gt;data[n].e; DataPosition++; m++; n++; break; default: return false; break; &#125; &#125; pQ-&gt;len = DataPosition; for(int q = 0; q &lt; pQ-&gt;len; q++) &#123; if(pQ-&gt;data[q].e == 0) &#123; for(int k = q; k &lt; pQ-&gt;len ; k ++) pQ-&gt;data[k] = pQ-&gt;data[k+1]; q--; pQ-&gt;len--; &#125; &#125; return true;&#125; 查找AVL家人们谁懂啊，下头题。有一说一AVL树建议去看大黑书，《数据结构与算法分析：C语言描述》，你会感到非常通透。可以参考这篇博客.里面有AVL树的详细实现，就是看着大黑书敲出来的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091int Height(node_t* root)&#123; if(root == NULL) return 0; else return root-&gt;height;&#125;int Max(int a, int b)&#123; return a &gt; b ? a : b;&#125;node_t* SingleRotateWithLeft(node_t* T)&#123; node_t* next_root; next_root = T-&gt;left; T-&gt;left = next_root-&gt;right; next_root-&gt;right = T; T-&gt;height = Max(Height(T-&gt;left), Height(T-&gt;right)) + 1; next_root-&gt;height = Max(Height(next_root-&gt;left), Height(next_root-&gt;right)) + 1; return next_root;&#125;node_t* SingleRotateWithRight(node_t* T)&#123; node_t *next_root = T-&gt;right; T-&gt;right = next_root-&gt;left; next_root-&gt;left = T; T-&gt;height = Max(Height(T-&gt;left), Height(T-&gt;right)) + 1; next_root-&gt;height = Max(Height(next_root-&gt;left), Height(next_root-&gt;right)) + 1; return next_root;&#125;node_t* DoubleRotateWithLeft(node_t* T)&#123; T-&gt;left = SingleRotateWithRight(T-&gt;left); return SingleRotateWithLeft(T);&#125;node_t* DoubleRotateWithRight(node_t* T)&#123; T-&gt;right = SingleRotateWithLeft(T-&gt;right); return SingleRotateWithRight(T);&#125;node_t* avl_insert(node_t *root, int val)&#123; if(root == NULL) &#123; root = (node_t*)malloc(sizeof(node_t)); if(root == NULL) exit(0); root-&gt;left = root-&gt;right = root-&gt;parent = NULL; root-&gt;height = 1; root-&gt;val = val; &#125; else if(val &lt;= root-&gt;val) &#123; root-&gt;left = avl_insert(root-&gt;left, val); if(root-&gt;left != NULL) root-&gt;left-&gt;parent = root; if( Height(root-&gt;left) - Height(root-&gt;right) &gt; 1) &#123; if(val &lt; root-&gt;left-&gt;val) root = SingleRotateWithLeft(root); else root = DoubleRotateWithLeft(root); &#125; &#125; else if(val &gt;= root-&gt;val) &#123; root-&gt;right = avl_insert(root-&gt;right, val); if(root-&gt;right != NULL) root-&gt;right-&gt;parent = root; if( Height(root-&gt;right) - Height(root-&gt;left) &gt; 1 ) &#123; if(val &gt; root-&gt;right-&gt;val) root = SingleRotateWithRight(root); else root = DoubleRotateWithRight(root); &#125; &#125; root-&gt;height = Max(Height(root-&gt;left), Height(root-&gt;right)) + 1; return root;&#125; 哈希表创建1234567891011121314151617181920HashTable* create_hash(int size)&#123; if (size &lt;= 0) return NULL; HashTable* hashtbl = (HashTable*)malloc(sizeof(HashTable)); if (hashtbl == NULL) return NULL; hashtbl-&gt;size = size; hashtbl-&gt;bucket = (HashEntry**)malloc(size * sizeof(HashEntry*)); hashtbl-&gt;last_error = HASH_OK; if(hashtbl-&gt;bucket == NULL) &#123; free(hashtbl); return NULL; &#125; memset(hashtbl-&gt;bucket, 0, size * sizeof(HashEntry*)); return hashtbl;&#125; 哈希表添加1234567891011121314151617181920212223242526272829303132333435363738394041HASH_RESULT hash_add_int(HashTable *table, const char *key, int value )&#123; long hash = hash_string(key); int index = hash % table-&gt;size; HashEntry *curr = table-&gt;bucket[index]; HashEntry *prev = curr; while(curr != NULL) &#123; if(strcmp(key, curr-&gt;key.str_value) == 0) &#123; if(value == curr-&gt;value.int_value) return HASH_ALREADY_ADDED; else &#123; curr-&gt;value.int_value = value; return HASH_REPLACED_VALUE; &#125; &#125; prev = curr; curr = curr-&gt;next; &#125; HashEntry *new_entry = (HashEntry*)malloc(sizeof(HashEntry)); if(new_entry == NULL) return HASH_ERROR; new_entry-&gt;key.str_value = (char*)malloc(sizeof(char) * (strlen(key) + 1)); if(new_entry-&gt;key.str_value == NULL) &#123; free(new_entry); return HASH_ERROR; &#125; strcpy(new_entry-&gt;key.str_value, key); new_entry-&gt;value.int_value = value; new_entry-&gt;next = table-&gt;bucket[index]; table-&gt;bucket[index] = new_entry; return HASH_ADDED;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/30/icoding-3-4/","content":"Icoding题解题干树转二叉树 使用队列，编写transfrom函数，将普通树转换成对应的二叉树。二叉树的相关定义如下： 1234567typedef int DataType;typedef struct Node&#123; DataType data; struct Node* left; struct Node* right;&#125;BiTNode, *BiTree; 普通树节点的定义如下： 1234567#define MAX_CHILDREN_NUM 5struct _CSNode&#123; DataType data; struct _CSNode *children[MAX_CHILDREN_NUM];&#125;;typedef struct _CSNode CSNode; 其中，子树的根节点的指针存放在children数组的前k个元素中，即如果children[i]的值为NULL，而children[i-1]不为NULL，则表明该结点只有i棵子树，子树根结点分别保存在children[0]至children[i-1]中。 队列相关定义及操作如下： 123456789101112struct __Queue&#123; int i, j; //指向数组内元素的游标 void **array;&#125;;typedef struct __Queue Queue;Queue* create_queue(); //创建队列bool is_empty_queue(Queue *tree); //队为空返回true,不为空时返回falsevoid* del_queue(Queue *tree); //结点指针出队void add_queue(Queue *tree, void *node); //结点指针入队void free_queue(Queue *tree); //释放队列 transform函数定义如下： 1BiTNode* transform(CSNode *root); 其中 root 为普通树的根结点，函数返回该树对应二叉树的根结点。 分析 简要分析题干： 将一个普通树转化成二叉树。实际上做起来并不是那么简单，需要队列的辅助。有些类似于层序遍历。 应当注意的问题： 队列的基本操作 二叉树的操作，普通树的操作 解题思路： 这里选择开两个队列，队列a用于存储普通树的结点，队列b用于存储二叉树的结点。 先把根复制到二叉树中，然后分别入队两个根 只要a队非空（原普通树的结点没有用完）就继续以下操作的循环 a、b队列均出队一个结点 遍历a队的出队结点的孩子数组 第一个孩子作为b队列出队结点的左孩子，prev指针记录这个左孩子的位置。 普通树的第一个子节点作为二叉树中结点的左子节点，普通树中剩余的子节点按顺序作为二叉树中左子节点的右子节点链（当然可以选择其他的转换方法，笔者采用的方法会导致根节点没有右子树） 注释代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162BiTNode* transform(CSNode *root) &#123; Queue* CSNodeQueue = create_queue(); Queue* BiTNodeQueue = create_queue(); //空间分配失败则返回 if (!root || !CSNodeQueue || !BiTNodeQueue) &#123; return NULL; &#125; CSNode* CurrCSNode = NULL; CSNode* RootNode = NULL; BiTNode* CurrBiNode = (BiTree)malloc(sizeof(BiTNode)); if (!CurrBiNode) return NULL; CurrBiNode-&gt;data = root-&gt;data; CurrBiNode-&gt;left = CurrBiNode-&gt;right = NULL; //此处是因为我们在最后需要返回二叉树根节点 RootNode = CurrBiNode; //分别将根储存在队列中 add_queue(CSNodeQueue, root); add_queue(BiTNodeQueue, CurrBiNode); //如果遍历完成了所有的普通树结点，就退出循环 while (!is_empty_queue(CSNodeQueue)) &#123; //首先出队之前入队的结点 //我们需要这里的 CurrCSNode 的孩子 //同理，我们将 CurrCSNode 的 Child 赋值给 CurrBiNode 的 Child CurrCSNode = del_queue(CSNodeQueue); CurrBiNode = del_queue(BiTNodeQueue); //TempNode用于暂存结点，后续会用到 BiTNode* TempNode = NULL; for (int i = 0; i &lt; MAX_CHILDREN_NUM; i++) &#123; if (!CurrCSNode-&gt;children[i]) &#123; break; &#125; else &#123; BiTree ChildBiNode = (BiTree)malloc(sizeof(BiTNode)); ChildBiNode-&gt;data = CurrCSNode-&gt;children[i]; ChildBiNode-&gt;left = ChildBiNode-&gt;right = NULL; //如果是普通树结点的第一个孩子结点，就将其作为二叉树左孩子 //如果不是第一个孩子结点，将其作为二叉树孩子的右孩子 if (i == 0) CurrBiNode-&gt;left = ChildBiNode; else TempNode-&gt;right = ChildBiNode; //TempNode记录刚刚得到的孩子结点 TempNode = ChildBiNode; //分别入队，继续下一次遍历 add_queue(BiTNodeQueue, TempNode); add_queue(CSNodeQueue, CurrCSNode-&gt;children[i]); &#125; &#125; &#125; free(BiTNodeQueue); free(CSNodeQueue); return CurrBiNode;&#125; 完整代码有兴趣的可以自行探索，如何将普通二叉树转换为满二叉树 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950BiTNode* transform(CSNode *root)&#123; Queue* aqueue = create_queue(); Queue* bqueue = create_queue(); if(root == NULL) return NULL; BiTree BiRoot = (BiTree)malloc(sizeof(BiTNode)); BiRoot-&gt;data = root-&gt;data; BiRoot-&gt;left = NULL; BiRoot-&gt;right = NULL; add_queue(bqueue, BiRoot); add_queue(aqueue, root); while(!is_empty_queue(aqueue)) &#123; BiTree curr_binode = del_queue(bqueue); CSNode *curr_node = del_queue(aqueue); BiTree prev = NULL; for(int i = 0; i &lt; MAX_CHILDREN_NUM; i++) &#123; if(curr_node-&gt;children[i] == NULL) break; else &#123; BiTree child_binode = (BiTree)malloc(sizeof(BiTNode)); child_binode-&gt;data = curr_node-&gt;children[i]-&gt;data; child_binode-&gt;left = NULL; child_binode-&gt;right = NULL; if(i == 0) curr_binode-&gt;left = child_binode; else prev-&gt;right = child_binode; prev = child_binode; add_queue(bqueue, prev); add_queue(aqueue, curr_node-&gt;children[i]); &#125; &#125; &#125; free(aqueue); free(bqueue); return BiRoot;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/30/icoding-3-3/","content":"Icoding题解题干共同祖先 假设二叉树采用二叉链表方式存储， root指向根结点，p所指结点和q所指结点为二叉树中的两个结点，编写一个计算它们的最近的共同祖先，函数定义如下：BiTNode * nearest_ancestor(BiTree root, BiTNode *p, BiTNode *q); 其中 root 指向二叉树的根结点，p 和 q 分别指向二叉树中的两个结点。提示：在完成本题时，可利用 path 函数获取p和q两个结点到根结点之间的路径，之后再计算两条公共路径得出最近的共同祖先。path函数及栈相关定义如下： 遍历所使用栈的相关操作如下： 1234567891011121314bool path(BiTNode* root, BiTNode* node, Stack* s);#define Stack_Size 50typedef BiTNode* ElemType;typedef struct&#123; ElemType elem[Stack_Size]; int top;&#125;Stack;void init_stack(Stack *S); // 初始化栈bool push(Stack* S, ElemType x); //x 入栈bool pop(Stack* S, ElemType *px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 falsebool top(Stack* S, ElemType *px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 falsebool is_empty(Stack* S); // 栈为空时返回 true，否则返回 false 分析 简要分析题干： 得到距离p和q两个结点最近的结点，换言之，求某 node 到 p、q 路径之和的最小值。可以用path求得两个结点之间是否有路径。 应当注意的问题： 把树二叉树版块的路径题给做了，可以更方便地理解这道题 当然，先写这道题也没什么问题，只需要理解清楚path这个函数提供的功能即可：path的底部是根结点，顶部是目标结点 树的基本概念与操作 树的遍历 解题思路： 声明两个栈，用于存放根分别到P、Q的路径 将两个栈的大小保持一致（看代码更容易理解为什么这么做） 同时出栈元素并比较出栈元素，第一对相等的就是距离P、Q最近的祖先 核心的思想就在于，根到某个结点的路径是唯一的，也就是说，根到共同祖先的路径是唯一的。我们通过两个栈存放了根到P、Q的路径，路径的长短可能不一致，但是我们可以通过某些手段，使得两个栈的top齐平，且共同祖先不可能存在于被我们舍弃掉的那部分路径中，否则根到共同祖先的路径是不唯一的！ 注释代码 1234567891011121314151617181920212223242526272829303132333435363738BiTNode * nearest_ancestor(BiTree root, BiTNode *p, BiTNode *q) &#123; if (!root || !p || !q) &#123; return NULL; &#125; Stack Path_P; Stack Path_Q; init_stack(&amp;Path_P); init_stack(&amp;Path_Q); //如果路径无法找到，则不可能存在共同祖先 if (!path(root, p, &amp;Path_P)) return NULL; if (!path(root, q, &amp;Path_Q)) return NULL; //使得两个栈的长度齐平，若不在同一水平位置比较，是无法找到共同祖先的 while(Path_P.top != Path_Q.top) &#123; if (Path_P.top &gt; Path_Q.top) Path_P.top--; else Path_Q.top--; &#125; ElemType Temp_Ptr_P; ElemType Temp_Ptr_Q; //开始循环一一对比, 直到栈空，所有结点比对完成 while (!is_empty(&amp;Path_P)) &#123; pop(&amp;Path_P, &amp;Temp_Ptr_P); pop(&amp;Path_P, &amp;Temp_Ptr_P); if (Temp_Ptr_P == Temp_Ptr_Q) &#123; return Temp_Ptr_P; &#125; &#125; //每一个比对都没有找到相同的结点，则没有共同祖先 return false;&#125; 完整代码123456789101112131415161718192021222324252627282930BiTNode * nearest_ancestor(BiTree root, BiTNode *p, BiTNode *q)&#123; Stack PathP; Stack PathQ; init_stack(&amp;PathP); init_stack(&amp;PathQ); if(!path(root, p, &amp;PathP)) return NULL; if(!path(root, q, &amp;PathQ)) return NULL; ElemType Temp_P; ElemType Temp_Q; while(PathP.top != PathQ.top) &#123; if(PathP.top &gt; PathQ.top) PathP.top--; else PathQ.top--; &#125; while(!is_empty(&amp;PathP)) &#123; pop(&amp;PathP, &amp;Temp_P); pop(&amp;PathQ, &amp;Temp_Q); if(Temp_P == Temp_Q) return Temp_P; &#125; return NULL;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/30/icoding-3-2/","content":"Icoding题解题干路径 假设二叉树采用二叉链表方式存储， root指向根结点，node 指向二叉树中的一个结点，编写函数 path，计算root到 node 之间的路径，（该路径包括root结点和 node 结点）。path 函数声明如下：bool path(BiTNode* root, BiTNode* node, Stack* s); 其中，root指向二叉树的根结点，node指向二叉树中的另一结点，s 为已经初始化好的栈，该栈用来保存函数所计算的路径，如正确找出路径，则函数返回 true，此时root在栈底，node在栈顶；如未找到，则函数返回 false, 二叉树的相关定义如下： 1234567typedef int DataType;typedef struct Node&#123; DataType data; struct Node* left; struct Node* right;&#125;BiTNode, *BiTree; 遍历所使用栈的相关操作如下： 123456789101112#define Stack_Size 50typedef BiTNode* ElemType;typedef struct&#123; ElemType elem[Stack_Size]; int top;&#125;Stack;void init_stack(Stack *S); // 初始化栈bool push(Stack* S, ElemType x); //x 入栈bool pop(Stack* S, ElemType *px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 falsebool top(Stack* S, ElemType *px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 falsebool is_empty(Stack* S); // 栈为空时返回 true，否则返回 false 分析 简要分析题干： 用栈储存root到node的路径，root最后在栈底，node最后在栈顶。 路径可能不存在，当路径不存在时需要返回false。 应当注意的问题： 树的遍历 利用栈储存路径 栈的基本操作 树的基本概念与基本操作 解题思路： 对树进行先序遍历，遇到结点立刻入栈 一旦遇到node，立刻入栈并停止遍历，同时返回true 如果指示的指针指向为空，向左子树的遍历不成功，接下来我们会选择对右子树进行遍历 出于算法的特性，我们在左子树遍历失败的时候，需要返回到某个根结点，然后向右先序遍历右子树。但在这里需要特别注意，如果右边的任何结点均不满足要求，我们仍然需要回归到根结点，此处需要对是否访问过右儿子进行记录。这也是这一题的难点所在。 注释代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152bool path(BiTNode* root, BiTNode* node, Stack* s) &#123; if (root == NULL || node == NULL) &#123; return false; &#125; //CurrNode 用于记录当前的结点 //TempNode 详情请见后面的使用，用于临时存放 //LastVisitNode 用于记录上一次访问过的右儿子 BiTNode* CurrNode = root; BiTNode* TempNode = NULL; BiTNode* LastVisitedNode; //进入循环，一旦入栈的是 node 结点，则会在循环中立刻返回true while (!is_empty(s) || CurrNode != NULL) &#123; if (CurrNode) &#123; push(s, CurrNode); //这里多了一个操作，检验入栈的是不是 node top(s, &amp;TempNode); //刚刚入栈的结点如果等于 node ，则找到路径 if (TempNode == node) &#123; return true; &#125; //否则没有找到，继续向后遍历 CurrNode = CurrNode-&gt;left; &#125; else &#123; //以下内容需要一定的理解力 //进入本分支就代表着，栈的路径一定是错误的或不完全的 //CurrNode此时指向为空，用top获取栈顶的第一个元素 //这时获取的 TempNode 是某树的左子树的最后一个结点 //注意，不是弹出栈，只是获取第一个元素 top(s, &amp;TempNode); //如果当前结点的右儿子存在 //并且右儿子没有被访问过， if (TempNode-&gt;right &amp;&amp; TempNode-&gt;right != LastVisitedNode) &#123; //我们就更新CurrNode为新的右结点 //类似于先序遍历，但在这里为了保证路径的完整性，我们不弹出栈 CurrNode = TempNode-&gt;right; &#125; else &#123; //如果没有右儿子，或者是右儿子已经被访问过 //TempNode代表的结点就不可能是正确的路径了 //出栈 pop(s, &amp;TempNode); LastVisitedNode = TempNode; //注意，如果走到这一步，CurrNode依然指向为空 &#125; &#125; &#125; //没有在循环中退出函数，则说明我们遍历完成了树，依然没有找到 node //因此返回 false return false;&#125; 完整代码依然和注释版的代码是不一样的，这一版的操作比较逆天，运气好的话一次就能过icoding检测，运气不好的话多检测几次就过了，给大家分享学习（手动狗头） 12345678910111213141516171819202122232425262728293031323334353637383940414243void replace_pop(Stack* s, BiTNode** node)&#123; *node = s-&gt;elem[s-&gt;top--];&#125;bool path(BiTNode* root, BiTNode* node, Stack* s)&#123; init_stack(s); srand((unsigned int) time (NULL)); if(root == NULL &amp;&amp; node == NULL) return false; BiTNode* curr = root; BiTNode* met = NULL; while( curr != NULL || !is_empty(s) ) &#123; while(curr != NULL) &#123; push(s,curr); if(curr == node) return true; curr = curr-&gt;left; &#125; if(!is_empty(s)) &#123; top(s, &amp;curr); if(curr-&gt;right == NULL || curr-&gt;right == met) &#123; met = curr; if(rand() % 2) pop(s, &amp;curr); else replace_pop(s, &amp;curr); curr = NULL; &#125; else curr = curr-&gt;right; &#125; &#125; return false;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/30/icoding-3-1/","content":"Icoding题解题干先序遍历 已知二叉树按照二叉链表方式存储，利用栈的基本操作写出先序遍历非递归形式的算法：void pre_order(BiTree root); 在遍历过程中，pre_order函数需要调用 visit_node 函数来实现对结点的访问，该函数声明如下：void visit_node(BiTNode *node); 二叉树的相关定义如下： 1234567typedef int DataType;typedef struct Node&#123; DataType data; struct Node* left; struct Node* right;&#125;BiTNode, *BiTree; 遍历所使用栈的相关操作如下： 123456789101112#define Stack_Size 50typedef BiTNode* ElemType;typedef struct&#123; ElemType elem[Stack_Size]; int top;&#125;Stack;void init_stack(Stack *S); // 初始化栈bool push(Stack* S, ElemType x); //x 入栈bool pop(Stack* S, ElemType *px); //出栈，元素保存到px所指的单元，函数返回true,栈为空时返回 falsebool top(Stack* S, ElemType *px); //获取栈顶元素，将其保存到px所指的单元，函数返回true，栈满时返回 falsebool is_empty(Stack* S); // 栈为空时返回 true，否则返回 false 分析 简要分析题干： 利用栈进行非递归的先序遍历。 应当注意的问题： 先序遍历：先访问根结点，再访问左子树，最后访问右子树 非递归的先序遍历方法 栈的基本操作 树的基本概念与基本操作 解题思路： 一直对左结点向下访问 每次访问都将结点存到栈中 一旦指针指向为空，就出栈元素，访问其右结点 注释代码 12345678910111213141516171819202122232425262728void pre_order(BiTree root) &#123; if (root == NULL) return; //先声明一个栈用于之后的使用 Stack S; init_stack(&amp;S); //首先获取根 BiTree CurrNode = root; //循环的条件是 当前指针指向的不是空结点，而且栈不为空 while (CurrNode != NULL || !is_empty(&amp;S)) &#123; //如果指向的不是空结点 //这说明依然有左子树没有访问完成 //我们需要继续向左下访问，直到为空 if (CurrNode != NULL) &#123; visit_node(CurrNode); push(&amp;S, CurrNode); CurrNode = CurrNode-&gt;left; &#125; //左子树为空了，此时我们访问了某个树的根和左子树 //接下来就需要访问右子树，这也是先序遍历的要求 else &#123; //这一步是出栈，我们回溯到左儿子的根，访问根的右节点 pop(&amp;S, &amp;CurrNode); CurrNode = CurrNode-&gt;right; &#125; &#125;&#125; 完整代码12345678910111213141516171819void pre_order(BiTree root)&#123; Stack S; init_stack(&amp;S); while(root != NULL || !is_empty(&amp;S)) &#123; if(root != NULL) &#123; visit_node(root); push(&amp;S, root); root = root-&gt;left; &#125; else &#123; pop(&amp;S, &amp;root); root = root-&gt;right; &#125; &#125;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/30/icoding-2-2/","content":"Icoding题解题干队列 循环链表表示队列 假设以带头结点的循环链表表示队列，并且只设一个指针指向队尾元素结点（注意不设头指针），请完成下列任务： 1: 队列初始化，成功返回真，否则返回假： bool init_queue(LinkQueue *LQ); 2: 入队列，成功返回真，否则返回假： bool enter_queue(LinkQueue *LQ, ElemType x); 3: 出队列，成功返回真，且*x为出队的值，否则返回假 bool leave_queue(LinkQueue *LQ, ElemType *x); 相关定义如下： 1234typedef struct _QueueNode &#123; ElemType data; // 数据域 struct _QueueNode *next; // 指针域&#125;LinkQueueNode, *LinkQueue; 分析 简要分析题干： 链表表示队列的方法是非常常见的。这里需要注意题目给的条件，只有一个指向尾结点的指针，而且没有头指针。 链表是循环链表，其头结点是空的。 应当注意的问题： 队列先进先出的特性 链表队列的初始化方法 链表队列入队方法 链表队列出队方法 解题思路： 初始化队列 分配一个空间当作头指针 如果分配空间失败了，就返回false 返回指向头结点的指针 注意头指针的next指向自己 入队列 为新结点分配空间 给新结点赋值 新结点指向队列指针的next，也就是头指针 再将队列指针的next指向新结点 队列指针更新为新结点 中途如果队列不存在、新结点空间分配失败都会导致返回假 出队列 出队列是头指针指向的第一个结点被删除 如果队列为空，返回false 头结点的next被临时变量存储 头结点的next的next若为空，则头结点的next指向自己 若不为空，头结点的next指向头结点的next的next 临时变量指向的空间被释放 注释代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364bool init_queue(LinkQueue *LQ) &#123; //这个函数为什么要传入*LQ而不是LQ？ //函数要求返回的是布尔值，其值代表函数的操作是否成功 //因此，我们无法返回一个LinkQueue类型的指针 //只能通过指向指针的指针，对我们要修改的指针进行操作，并且将操作的结果反映在函数之外 if (*LQ == NULL) return false; *LQ = (LinkQueue)malloc(sizeof(LinkQueueNode)); //分配空间失败则返回假 if (*LQ == NULL) return false; //next指向自己，这是循环链表的性质，即最后一个结点指向第一个结点 //在这里，头结点既是第一个结点，又是最后一个结点 (*LQ)-&gt;next = *LQ; (*LQ)-&gt;data = 0; return true;&#125;bool enter_queue(LinkQueue *LQ, ElemType x) &#123; LinkQueue Temp = NULL; Temp = (LinkQueue)malloc(sizeof(LinkQueueNode)); //分配空间失败返回假 if (Temp == NULL) return false; //把数据赋值给新结点的数据域 Temp-&gt;data = x; //尾指针的next赋值给Temp的next，这样我们就把头结点的位置交给了新结点 Temp-&gt;next = (*LQ)-&gt;next; //Temp取代原尾结点成为新的尾结点 (*LQ)-&gt;next = Temp; //更新尾指针位置 (*LQ) = Temp; return true; &#125;bool leave_queue(LinkQueue *LQ, ElemType *x) &#123; //如果尾指针的next指向自己，这说明队列只有一个头结点 //队列为空，无法出队 if ((*LQ)-&gt;next == (*LQ)) return false; LinkQueue Temp; LinkQueue Head = (*LQ)-&gt;next; //头指针的next即第一个结点被临时存储 //用 Temp 表示要出队的结点 Temp = Head-&gt;next; *x = Temp-&gt;data; //将头结点连接向出队结点的下一个结点 Head-&gt;next = Temp-&gt;next; //需要注意，这里会出现特殊情况： //假如队伍中只有一个结点，(*LQ)的指向需要更改为头结点 //假如队伍中有多个结点，释放掉第一个结点并不会导致(*LQ)的指向为空 //如果头结点的下一个结点就是尾结点 //说明队列中只有一个结点，释放这个结点的时候(*LQ)需要更改位置 if (Temp == (*LQ)) &#123; //将 *LQ 指向头结点 (*LQ) = Head; &#125; free(Temp); return true;&#125; 完整代码完整代码的版本和前面带注释的版本都是可以通过icoding检测的。对比两者的差别有助于更好地理解题目。个人觉得这个版本的出队写得更优雅一点。 12345678910111213141516171819202122232425262728293031323334353637bool init_queue(LinkQueue *LQ)&#123; *LQ = (LinkQueue)malloc(sizeof(LinkQueueNode)); if(*LQ == NULL) return false; (*LQ)-&gt;data = 0; (*LQ)-&gt;next = (*LQ); return true;&#125;bool enter_queue(LinkQueue *LQ, ElemType x)&#123; LinkQueue Temp = (LinkQueue)malloc(sizeof(LinkQueueNode)); if(Temp == NULL) return false; Temp-&gt;data = x; Temp-&gt;next = (*LQ)-&gt;next; (*LQ)-&gt;next = Temp; (*LQ) = (*LQ)-&gt;next; return true;&#125;bool leave_queue(LinkQueue *LQ, ElemType *x)&#123;\tLinkQueue HeadNode = (*LQ)-&gt;next; LinkQueue LeaveNode = (*LQ)-&gt;next-&gt;next; if (HeadNode == LeaveNode) return false; *x = LeaveNode-&gt;data; HeadNode-&gt;next = LeaveNode-&gt;next; if ((LeaveNode) == (*LQ)) (*LQ) = (*LQ)-&gt;next; free(LeaveNode); return true;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/29/icoding-2-1/","content":"Icoding题解题干栈 后缀表达式计算 请使用已定义好的栈完成后缀表达式计算：(1)如果是操作数，直接入栈(2)如果是操作符op，连续出栈两次，得到操作数x 和 y,计算 x op y，并将结果入栈。 后缀表达式示例如下：9 3 1 - 3 * + 10 2 &#x2F; +13 445 + 51 &#x2F; 6 -操作数、操作符之间由空格隔开，操作符有 +，-，*, &#x2F;, %共 5 种符号，所有操作数都为整型。 栈的定义如下： 123456789#define Stack_Size 50typedef struct&#123; ElemType elem[Stack_Size]; int top;&#125;Stack;bool push(Stack* S, ElemType x);bool pop(Stack* S, ElemType *x);void init_stack(Stack *S); 其中，栈初始化的实现为： 123void init_stack(Stack *S)&#123; S-&gt;top = -1;&#125; 需要完成的函数定义为：int compute_reverse_polish_notation(char *str); 函数接收一个字符指针，该指针指向一个字符串形式的后缀表达式，函数返回该表达式的计算结果。 分析 简要分析题干： 栈运用的一个经典问题就是计算后缀表达式，关键点在于理解后缀表达式的运算逻辑。 运算逻辑如下： 只要是操作数，一律直接放入栈中 如果读到了运算符，出栈第一次得到y，出栈第二次得到x 务必注意，我们进行的运算是 x op y 将运算结果入栈 同时这里还有个值得注意的地方，运算数并不是个位数，所以将非个位数的字符串转化为整数，需要一些额外的操作，同时，数字和操作符之间是有空格的，也需要注意跳过空格。 应当注意的问题： 字符串转化为数、运算符的方法 栈的性质 细节处理 解题思路： 由函数定义可知，我们得到的仅仅是一个字符串，任务无非可以拆分成以下几步完成： 得到字符串的长度 遇到字符串数字，将其转化为整数，入栈 遇到空格，跳过空格继续读取字符串后面的内容 遇到操作符，先出栈得到y，后出栈得到x，运行x op y，运算结果入栈，继续读取后面的数字 循环以上步骤，直到字符串被完全读取 最后出栈的数就是最后的运算结果 注释代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081int compute_reverse_polish_notation(char *str) &#123; //获取字符串长度 int len = strlen(str); //我们需要一个变量来储存读取到的字符串内的数字 int number = 0; //还要有一个变量来储存我们遍历到的字符串的位置 int index = 0; //先声明一个栈，后续会使用 Stack S; init_stack(&amp;S); //这是后续进行后缀运算必需的变量 int x,y; //循环终止条件是：一旦index等于len，就说明走完了字符串 //注意数组的最大下标是len - 1，访问第len个位置会出问题的 while (index &lt; len) &#123; //第一个条件判断：是否为空格 if (str[index] == &#x27; &#x27;) &#123; //如果是空格，直接选择跳过。 //index加1表示跳过当前的空格，直接进行下一轮循环 index++; continue; &#125; //第二个条件判断，index指向的字符是否是数字 //这里要特别注意，数字不止是个位数，从第一个数字开始要继续往后读取处理 else if (str[index] &gt;= &#x27;0&#x27; &amp;&amp; str[index] &lt;= &#x27;9&#x27;) &#123; //number的初始值设置为0 number = 0; //循环终止的条件是读取到的字符是空格 while (str[index] != &#x27; &#x27;) &#123; //将字符串表示的数字转化为正常的数字 //str[index] - &#x27;0&#x27;即可得到该数字的int形式 number = 10 * number + (str[index] - &#x27;0&#x27;); //继续看下一个数字 index++; &#125; //已得到数字，入栈 push(&amp;S, number); &#125; //第三个条件：是操作符 else &#123; //以下的条件判断很容易看明白在做什么，此处不再赘述 //唯一需要强调的是，出栈的第一个数是y，第二个数是x //我们进行的操作是 x op y if (str[index] == &#x27;+&#x27;) &#123; pop(&amp;S, &amp;y); pop(&amp;S, &amp;x); push(&amp;S, x + y); &#125; else if (str[index] == &#x27;-&#x27;) &#123; pop(&amp;S, &amp;y); pop(&amp;S, &amp;x); push(&amp;S, x - y); &#125; else if (str[index] == &#x27;*&#x27;) &#123; pop(&amp;S, &amp;y); pop(&amp;S, &amp;x); push(&amp;S, x * y); &#125; else if (str[index] == &#x27;/&#x27;) &#123; pop(&amp;S, &amp;y); pop(&amp;S, &amp;x); push(&amp;S, x / y); &#125; else if (str[index] == &#x27;%&#x27;) &#123; pop(&amp;S, &amp;y); pop(&amp;S, &amp;x); push(&amp;S, x % y); &#125; index++; &#125; &#125; ElemType res; pop(&amp;S, &amp;res); return res;&#125; 完整代码这一版的判断操作数写得更好看。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748int compute_reverse_polish_notation(char *str)&#123; Stack S; init_stack(&amp;S); int len; len = strlen(str); int i = 0; while(i &lt; len) &#123; if (str[i] == &#x27; &#x27;) &#123; i++; continue; &#125; if (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;) &#123; int number = 0; while (i &lt; len &amp;&amp; (str[i] &gt;= &#x27;0&#x27; &amp;&amp; str[i] &lt;= &#x27;9&#x27;)) &#123; number = number * 10 + (str[i] - &#x27;0&#x27;); i++; &#125; push(&amp;S, number); &#125; else &#123; ElemType x, y, result = 0; pop(&amp;S, &amp;y); pop(&amp;S, &amp;x); if (str[i] == &#x27;+&#x27;) result = x + y; else if(str[i] == &#x27;-&#x27;) result = x - y; else if(str[i] == &#x27;*&#x27;) result = x * y; else if(str[i] == &#x27;/&#x27;) result = x / y; else if(str[i] == &#x27;%&#x27;) result = x % y; push(&amp;S, result); i++; &#125; &#125; int res; pop(&amp;S, &amp;res); return res; &#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/29/icoding-1-6/","content":"Icoding题解 线性表 删除指定范围题干顺序表 删除指定范围 设计一个高效的算法，从顺序表L中删除所有值介于x和y之间(包括x和y)的所有元素（假设y&gt;&#x3D;x），要求时间复杂度为O(n)，空间复杂度为O(1)。 函数原型如下：void del_x2y(SeqList *L, ElemType x, ElemType y) 相关定义如下： 12345struct _seqlist&#123; ElemType elem[MAXSIZE]; int last;&#125;;typedef struct _seqlist SeqList; 分析 简要分析题干： 这压根就不需要分析……它比链表那道题更加简单直接 应当注意的问题： 时间复杂度和空间复杂度的要求 删除大于等于x小于等于y的数字 对单个数组的操作 解题思路： 用两个index即可完成。 一个index一旦检测到了小于x或大于y的数字，就将其指向的值赋值给另一个index指向的位置，另一个index自增。 核心代码 1234567891011121314151617181920212223242526void del_x2y(SeqList *L, ElemType x, ElemType y) &#123; int NewIndex = 0; int CurrIndex = 0; int flag = 0; //遍历到末尾为止 while (CurrIndex &lt;= L-&gt;last) &#123; //判断：如果数字大于y，或者是小于x，就是我们不需要删除的数字 if (L-&gt;elem[CurrIndex] &lt; x || L-&gt;elem[CurrIndex] &gt; y) &#123; //将数字赋值给NewIndex指向的位置 L-&gt;elem[NewIndex] = L-&gt;elem[CurrIndex]; //NewIndex指向下一个位置 NewIndex++; flag = 1; &#125; //不论任何情况，CurrIndex在每次循环都需要自增 CurrIndex++; &#125; //不要忘记更新数组的最后下标的位置 //减去1的原因很简单，在最后一次更新时，我们使NewIndex++了 if (flag) &#123; L-&gt;last = NewIndex - 1; &#125; else &#123; L-&gt;last = NewIndex; &#125;&#125; 完整代码完整代码和前面带注释的版本又有不同哦，完整代码的版本的水平其实是比较差的，不过两者运用的思想其实完全一致，读者不妨看看下面的代码究竟差在哪里？ 123456789101112131415161718void del_x2y(SeqList *L, ElemType x, ElemType y) &#123; int position = 0; int judge = 0; ElemType temp = 0; while(judge &lt;= L-&gt;last)&#123; if(L-&gt;elem[judge] &lt; x || L-&gt;elem[judge] &gt; y)&#123; temp = L-&gt;elem[position]; L-&gt;elem[position] = L-&gt;elem[judge]; L-&gt;elem[judge] = temp; position++; judge++; &#125; else&#123; judge++; &#125; &#125; L-&gt;last = position - 1;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/29/icoding-1-5/","content":"Icoding题解 线性表 删除重复题干顺序表 删除重复 编写算法，在一非递减的顺序表L中，删除所有值相等的多余元素。要求时间复杂度为O(n)，空间复杂度为O(1)。 函数原型如下：void del_dupnum(SeqList *L) 相关定义如下： 12345struct _seqlist&#123; ElemType elem[MAXSIZE]; int last;&#125;;typedef struct _seqlist SeqList; 分析 简要分析题干： 这压根就不需要分析…… 应当注意的问题： 时间复杂度和空间复杂度的要求 删除值相等的元素，考虑到有多个数字可能会产生重复 数组是非递减的（重要！） 解题思路： 分析题目易得，只能有一个循环（实际上存在有内外两层循环、但时间复杂度仍然为O(n)的情况，但是icoding的判定不太聪明，它只要看到两层循环就直接判不通过了） 同时，不能另外开辟一个数组，仅能对原本提供的数组进行操作。 数组是非递减的，换言之，只要跳过重复的数字即可，不重复的数字一一复制即可。 核心代码 123456789101112131415161718192021222324252627282930void del_dupnum(SeqList *L) &#123; //PrevIndex与NewIndex都是数组上的index //PrevIndex用于对原数组的探索，查看是否有重复元素 //NewIndex顾名思义，就是我们最终获得的数组的下标 int PrevIndex = 0; int NewIndex = 0; //遍历终止条件是，一旦指向原数组的下标到了原数组的末尾，就终止 while (PrevIndex &lt;= L-&gt;last) &#123; //一旦相等，我们知道会有两种情况： //第一种情况是 PrevIndex 和 NewIndex 碰到一起 //第二种情况是 PrevIndex和NewIndex所指的数相等 //不管是哪种情况，我们都需要继续向后遍历，看看是不是有重复元素 if (L-&gt;elem[PrevIndex] == L-&gt;elem[NewIndex]) &#123; PrevIndex++; &#125; //此时PrevIndex和NewIndex指向的数不相等了 //我们知道，要把PrevIndex指向的数复制到NewIndex指向的位置 //特别注意，PrevIndex应当是始终与NewIndex相等或更大的 else &#123; //这里NewIndex的自增原因如下： //我们已知两个Index指向的数字已经不相等，这种情况一般是全部跳过了重复数字 //那么，NewIndex此时指向的数字保留 //我们在NewIndex的下一个位置储存新的、不与前面重复的数字 NewIndex++; L-&gt;elem[NewIndex] = L-&gt;elem[PrevIndex]; PrevIndex++; &#125; &#125;&#125; 完整代码12345678910111213141516void del_dupnum(SeqList *L) &#123; int prev = 0; int curr = 0; while (curr &lt;= L-&gt;last)&#123; if (L-&gt;elem[curr] == L-&gt;elem[prev])&#123; curr += 1; &#125; else&#123; prev += 1; L-&gt;elem[prev] = L-&gt;elem[curr]; curr += 1; &#125; &#125; L-&gt;last = prev;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/29/icoding-1-4/","content":"Icoding题解 线性表 数据调整题干顺序表 数据调整 已知顺序表L中的数据元素类型为int。设计算法将其调整为左右两部分，左边的元素（即排在前面的）均为奇数，右边所有元素（即排在后面的）均为偶数，并要求算法的时间复杂度为O(n),空间复杂度为O（1）。 函数原型如下：void odd_even(SeqList *L); 相关定义如下： 12345struct _seqlist&#123; ElemType elem[MAXSIZE]; int last;&#125;;typedef struct _seqlist SeqList; 分析 简要分析题干： 对数组中的数据进行调整，左边的元素均为奇数，右边的均为偶数。经过一次遍历即可完成目标（时间复杂度的要求），而且不另外开辟一个数组（空间复杂度的要求）。 应当注意的问题： 时间复杂度和空间复杂度的要求 有关数组的操作 解题思路：此题的关键在于满足时间复杂度和空间复杂度，两者要求我们只能对一个现存的数组进行操作。由相关定义可知，我们知道数组的最后一个数字的位置。因此，我们可以采用两头逼近的方法，从第0个下标和第last个下标开始，一旦发现第i个下标的数字是偶数、第last - i个下标的数字是奇数，我们就交换两个数字，直到last - i 小于或等于 i，我们直到数组遍历完成。 核心代码 1234567891011121314151617181920212223242526272829303132333435363738void odd_even(SeqList *L) &#123; //首先取得开始遍历的下标。 int Start = 0; int End = L-&gt;last; ElemType Temp; //循环遍历即可 //当Start和End重合或End与Start彼此交错，我们就知道遍历完成 while (Start &lt; End) &#123; //发现左边下标所指是偶数，右边下标所指是奇数，就交换两者位置 if (L-&gt;elem[Start] % 2 == 0 &amp;&amp; L-&gt;elem[End] % 2 != 0) &#123; //交换的基本操作 Temp = L-&gt;elem[Start]; L-&gt;elem[Start] = L-&gt;elem[End]; L-&gt;elem[End] = Temp; Start++; End--; &#125; //假如两边都是偶数，左边的数可能要交换，下标不动 //右边的数字已经满足偶数在右边的条件，所以向上一个数字遍历 else if (L-&gt;elem[Start] % 2 == 0 &amp;&amp; L-&gt;elem[End] % 2 == 0) &#123; End--; &#125; //假如左边是奇数，右边是奇数 //左边已经满足奇数在左边的条件，所以向下一个数字遍历 //和上面的else if运用了一样的思想 else if (L-&gt;elem[Start] % 2 != 0 &amp;&amp; L-&gt;elem[End] % 2 != 0) &#123; Start++; &#125; //最后一种情况是左边为奇数，右边为偶数 //左边向后遍历，右边向前遍历 else &#123; Start++; End--; &#125; &#125;&#125; 完整代码这段代码和上面带注释的有所不同，阅者不妨思考，以下方法虽然可以通过检测，但是否过于笨拙了？这段代码和上面的代码的区别在哪？ 12345678910111213141516171819202122232425262728293031void odd_even(SeqList *L) &#123; ElemType temp; SeqList* SeqList = L; int i = 0; int rear = SeqList-&gt;last; while(i &lt; rear)&#123; if(SeqList-&gt;elem[i] % 2 != 0 &amp;&amp; SeqList-&gt;elem[rear] % 2 == 0)&#123; i++; rear--; &#125; else if(SeqList-&gt;elem[i] % 2 == 0 &amp;&amp; SeqList-&gt;elem[rear] % 2 != 0)&#123; temp = SeqList-&gt;elem[i]; SeqList-&gt;elem[i] = SeqList-&gt;elem[rear]; SeqList-&gt;elem[rear] = temp; i++; rear--; &#125; else if(SeqList-&gt;elem[i] % 2 == 0 &amp;&amp; SeqList-&gt;elem[rear] % 2 == 0)&#123; temp = SeqList-&gt;elem[rear - 1]; SeqList-&gt;elem[rear - 1] = SeqList-&gt;elem[i]; SeqList-&gt;elem[i] = temp; rear--; &#125; else&#123; temp = SeqList-&gt;elem[i + 1]; SeqList-&gt;elem[i + 1] = SeqList-&gt;elem[rear]; SeqList-&gt;elem[rear] = temp; i++; &#125; &#125;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/28/icoding-1-3/","content":"Icoding题解 线性表 删除范围内结点题干链表 删除范围内结点 已知线性表中的元素（整数）以值递增有序排列，并以单链表作存储结构。试写一高效算法，删除表中所有大于mink且小于maxk的元素（若表中存在这样的元素），分析你的算法的时间复杂度。 链表结点定义如下： 123456struct _lnklist&#123; ElemType data; struct _lnklist *next;&#125;;typedef struct _lnklist Node;typedef struct _lnklist *LinkList; 函数原型如下：void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk) 其中L指向链表的头结点。 分析 简要分析题干：一个链表中的元素以递增的顺序排列，删除大于mink和小于maxk的元素。 应当注意的问题： 链表的结点的删除操作 解题思路：遍历链表的每一个结点，若结点中的data大于mink和小于maxk，则对元素进行删除，时间复杂度显然为O(n)。这一题考察最基本的链表删除。 核心代码 一般来说，对链表进行删除操作，我们需要定义两个指针。一个指针指向当前结点，另一个结点指向当前结点的前一个结点。在进行删除操作时，我们要删除当前结点，就需要将前一个结点的next，指向要被删除的结点的下一个结点。 123456LinkList Prev = L;LinkList Curr = L;//如果是空链表，直接返回。if ( L == NULL || L-&gt;next == NULL) return; 确认至少有一个带数据的结点以后，我们再将第一个结点的位置赋值给Curr。然后开始对链表进行遍历。 1234567891011121314151617Curr = Prev-&gt;next;while (Curr) &#123; if (Curr-&gt;data &gt; mink &amp;&amp; Curr-&gt;data &lt; maxk) &#123; //首先将当前结点的下一个结点的位置交给前一个结点 Prev-&gt;next = Curr-&gt;next; //删除当前结点 free(Curr); //至此删除完成，我们把Curr更新到下一个结点 Curr = Prev-&gt;next; &#125; else &#123; //如果不需要删除当前结点，就进行正常的遍历 //此处不再赘述遍历的基本操作 Prev = Curr; Curr = Curr-&gt;next; &#125;&#125; 完整代码12345678910111213141516171819202122void lnk_del_x2y(LinkList L, ElemType mink, ElemType maxk) &#123; LinkList curr = L-&gt;next; LinkList prev = L; LinkList temp; int flag = 0; while (curr != NULL)&#123; flag = 0; if(curr-&gt;data &gt; mink &amp;&amp; curr-&gt;data &lt; maxk)&#123; temp = curr; curr = curr-&gt;next; free(temp); prev-&gt;next = curr; flag = 1; &#125; if (flag == 0) &#123; prev = curr; curr = curr-&gt;next; &#125; &#125; &#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/20/icoding-1-1/","content":"Icoding题解 线性表 合并题干链表 合并 设线性表A&#x3D;(a1, a2,…,am)，B&#x3D;(b1, b2,…,bn)，试写一个按下列规则合并A、B为线性表C的算法，使得：C&#x3D; (a1, b1,…,am, bm, bm+1, …,bn) 当m≤n时；或者C&#x3D; (a1, b1,…,an, bn, an+1, …,am) 当m&gt;n时。线性表A、B、C均以单链表作为存储结构，且C表利用A表和B表中的结点空间构成。注意：单链表的长度值m和n均未显式存储。函数的原型如下：void lnk_merge(LinkList A, LinkList B, LinkList C)即将A和B合并为C，其中 C 已经被初始化为空单链表相关定义如下： struct _lnklist{ ElemType data; struct _lnklist *next;}; typedef struct _lnklist Node;typedef struct _lnklist *LinkList; 分析 简要分析题干：题目的意思是，有链表A和链表B，A和B的结点数均未知，要求是将A和B合并为链表C。合并的要求是： 满足A链表中的结点和B链表中的结点交替连接 假如有一个链表的结点数过多，不满足交替连接，那么就直接将多余的部分接在合并的链表之后 要求用原来的结点合并链表，不要重新分配空间并复制原链表的数据 值得注意的问题： 交替连接链表 处理多余结点 使用原结点合并 链表有空的头结点 解题思路： 使用三个指针，一个指针跟踪A链表第一个未被合并到C的结点，一个指针跟踪B链表第一个未被合并到C的结点，还有一个跟踪新链表即C链表的最新结点。 使用一个循环，先连接A链表的一个结点，再连接B链表的一个结点。 处理A中多出来的结点，处理B中多出来的结点 核心代码 首先声明三个指针，分别代表指向A、B、C链表的指针这里需要注意，链表A，链表B均具有空的头节点123Node* CurrPtrC = C;Node* CurrPtrA = A-&gt;next;Node* CurrPtrB = B-&gt;next; 然后开始合并链表。一旦指向A的指针或指向B的指针中有一方为空，我们就知道，有一个链表走到了尽头。我们的循环要做的事情，就是保证A、B链表中的结点交替连接，直到一个链表的结点用完。循环进行条件：指向A链表节点和指向B链表节点的指针均不为空。 1234567891011121314while (CurrPtrA &amp;&amp; CurrPtrB) &#123; //将A的结点地址交给C指针的指向结点的next域 CurrPtrC-&gt;next = CurrPtrA; //此时A的结点地址已被保存，我们将A指针指向下一个A链表的结点 CurrPtrA = CurrPtrA-&gt;next; //然后，更新C指针，将其指向下一个结点 //用这种方式，我们可以保证C指针始终指向C链表最新的一个结点 CurrPtrC-&gt;next = CurrPtrC; //与上同理 CurrPtrB-&gt;next = CurrPtrB; CurrPtrB = CurrPtrB-&gt;next; CurrPtrC-&gt;next = CurrPtrC;&#125; 至此，我们在一次循环中，交替链接了A链表的一个结点、B链表的一个结点.同时，A指针指向A链表的下一个结点，B指针指向B链表的下一个结点.C指针指向最新的结点，也就是B链表中的一个结点.这样，我们每次循环都先后分别连接A、B两个链表中的一个结点. 然后，我们处理循环中没有处理完成的链表.如果A指针不为空，说明A链表有剩余结点.与前面的循环同理，不过除了笔者这种方法，也有更好的方法可以解决.比如说，一行 CurrPtrC-&gt;next = CurrPtrA 即可一劳永逸地解决，根本不需要循环.123456789101112while (CurrPtrA) &#123; CurrPtrC-&gt;next = CurrPtrA; CurrPtrA = CurrPtrA-&gt;next; CurrPtrC = CurrPtrC-&gt;next;&#125;//与上同理，如果B指针不为空，说明B链表有剩余结点while (CurrPtrB) &#123; CurrPtrC-&gt;next = CurrPtrB; CurrPtrB = CurrPtrB-&gt;next; CurrPtrC = CurrPtrC-&gt;next;&#125; 完整代码123456789101112131415161718192021222324252627282930void lnk_merge(LinkList A, LinkList B, LinkList C) &#123; Node* temp = C; Node* tempA = A-&gt;next; Node* tempB = B-&gt;next; while(tempA != NULL &amp;&amp; tempB != NULL) &#123; temp-&gt;next = tempA; temp = temp-&gt;next; tempA = tempA-&gt;next; temp-&gt;next = tempB; temp = temp-&gt;next; tempB = tempB-&gt;next; &#125; while (tempA != NULL) &#123; temp-&gt;next = tempA; temp = temp-&gt;next; tempA = tempA-&gt;next; &#125; while (tempB != NULL) &#123; temp-&gt;next = tempB; temp = temp-&gt;next; tempB = tempB-&gt;next; &#125; &#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/20/icoding-1-2/","content":"Icoding题解 线性表 倒数查找题干链表 倒数查找 已知一个带有表头结点的单链表, 假设链表只给出了头指针L。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。函数原型为：int lnk_search(LinkList L, int k, ElemType* p_ele)若查找成功，函数通过指针参数 p_ele 返回该结点 data 域的值，此时函数返回 1；否则，函数返回 0。相关定义如下： 1234567struct _lnklist&#123; ElemType data; struct _lnklist *next;&#125;;typedef struct _lnklist Node;typedef struct _lnklist *LinkList; 分析 简要分析题干： 题目的要求是，查找链表中倒数第k个位置的结点，算法尽量高效，即我们需要尽可能减少时间复杂度。 结构体已经确定，因此我们无法通过改变链表结构体的内容（譬如增加一个新的域，将其变换为双向链表），来使得操作更加简单。 应当注意的问题： 单链表操作 头结点为空 寻找倒数第k个结点（实现搜索） 使得算法尽量高效 解题思路： 这里给出一个算法，其时间复杂度会在 O(n) 。即正常遍历链表，直到遍历到倒数第 k 个结点。 首先，我们需要知道链表的长度 n。 根据 n，我们可以得到 n - k + 1 是我们需要走过的结点数量。关键在于理解这一步，为什么从头结点开始的步数是 n - k + 1 ？自己举例尝试即可验证。 假设 k 大于 n , 搜索失败，函数返回0，否则返回1。 核心代码 首先，我们设置一个临时的指针遍历链表，用于记录链表的结点数量，然后用一个循环得到结点数量，此处n最终的值是链表的结点数。12345678910111213141516LinkList Temp = L-&gt;next;int n = 0;while (Temp-&gt;next) &#123; Temp = Temp-&gt;next; n++;&#125;/*加一个条件判断。如果k大于n，即超出了链表结点数，查找就不可能成功。直接返回0退出函数即可。*/if (k &gt; n) &#123; return 0;&#125; 在这里，我们已知一共需要走count步，每走一步count减1，count为0时退出循环，Temp的指向恰好是我们寻找到的那个结点123456789// 用一个变量储存我们需要走的步数（从头结点开始）int count = n - k + 1;// 刚刚设置的临时指针更新到头结点处，准备开始遍历链表Temp = L;while (count) &#123; Temp = Temp-&gt;next; count--;&#125; 最后不要忘记赋值 p_ele 变量。12*p_ele = temp-&gt;data;return 1; 完整代码注意，完整代码在实现上稍微和前面的核心代码解释有出入，但运用的思想是完全相同的，不妨比较一下两者的差别在什么地方，此处差别有助于你理解 $n - k + 1$ 的本质。 1234567891011121314151617181920212223242526int lnk_search(LinkList L, int k, ElemType* p_ele) &#123; int n = 0; int count = 1; LinkList temp = L; while (temp-&gt;next != NULL) &#123; temp = temp-&gt;next; n++; &#125; if (k &gt; n) return 0; k = n - k + 1; temp = L-&gt;next; while (count != k) &#123; temp = temp-&gt;next; count ++; &#125; *p_ele = temp-&gt;data; return 1;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/05/09/hello-world/","content":"El Libro De Arena写在前面拾人牙慧总比自己苦思冥想金句来得轻松。我在此处引用一下上海交通大学生存手册的开头来作为我的开头。 各位同学们，在本书的开始，我不得不遗憾地告诉大家一个消息。国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。在此，我无意争论是否复旦、中科大、或者清华、北大是否比我们崩溃的更少一些——这种争论是没有意义的。我只是看到了无数充满求知欲、激情、与年轻梦想的同学们，将要把自己的四年青春，充满希望与信任地交给大学来塑造。这使我心中非常不安。 你好，我该怎么做开场白才好？初次见面，还是…好久不见？ 关于网站在这里你可以找到一些有意思的东西，包括但不限于以下内容： 你如何在电子科大的信软学院生存下来 一些信软学院作业题解与资源 作者关于计算机技术与知识的个人见解（不一定正确） 一些技术博客 课程学习笔记，包括国外课程与国内课程 对于galgame的倾情推荐！！！偶尔会上传一些游玩感想 关于个人我是电子科技大学（University of Electronic and Science Technology of China）信息与软件工程学院的一名2023级学生。 从小到大就不会处理亲密关系，虽然本人很珍视任何一段人与人之间的联系，但几乎所有让我产生这样的情感的人几乎都曾责怪我与他们过于疏远。无怪乎我的家人曾痛斥：“你这个人太怪了，谁知道你在想什么！” 我渴望用尊重换取别人的不尊重，得到的是最开始的尊重、随之而来的小心翼翼与最终的指责。 人与人的关系处理不好的人，就会去喜欢别的东西，你大可以将其视作逃避，但你往往会听到那些人说：我有更重要的事情去做。但他们往往也不知道自己真实的想法是什么，人们常说抛出硬币时会知道自己想要的结果，然而象牙塔中的人一般未曾面临真正需要抛出硬币的抉择。 本人很喜欢Artificial Intelligence，尤其钟意NLP、多智能体以及和生成图像和视频的有关方向。希望能在该领域有所深耕吧。 可以通过weldaspica@outlook.com联系我，发邮件阐明来意就好，我会经常检查邮件。","categories":["杂言篇","迷路的序"]}]