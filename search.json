[{"path":"/2024/06/20/icoding-1-2/","content":"Icoding题解 线性表 倒数查找题干链表 倒数查找 已知一个带有表头结点的单链表, 假设链表只给出了头指针L。在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。函数原型为：int lnk_search(LinkList L, int k, ElemType* p_ele)若查找成功，函数通过指针参数 p_ele 返回该结点 data 域的值，此时函数返回 1；否则，函数返回 0。相关定义如下： 1234567struct _lnklist&#123; ElemType data; struct _lnklist *next;&#125;;typedef struct _lnklist Node;typedef struct _lnklist *LinkList; 分析 简要分析题干： 题目的要求是，查找链表中倒数第k个位置的结点，算法尽量高效，即我们需要尽可能减少时间复杂度。 结构体已经确定，因此我们无法通过改变链表结构体的内容（譬如增加一个新的域，将其变换为双向链表），来使得操作更加简单。 应当注意的问题： 单链表操作 头结点为空 寻找倒数第k个结点（实现搜索） 使得算法尽量高效 解题思路： 这里给出一个算法，其时间复杂度会在 O(n) 。即正常遍历链表，直到遍历到倒数第 k 个结点。 首先，我们需要知道链表的长度 n。 根据 n，我们可以得到 n - k + 1 是我们需要走过的结点数量。关键在于理解这一步，为什么从头结点开始的步数是 n - k + 1 ？自己举例尝试即可验证。 假设 k 大于 n , 搜索失败，函数返回0，否则返回1。 核心代码 首先，我们设置一个临时的指针遍历链表，用于记录链表的结点数量，然后用一个循环得到结点数量，此处n最终的值是链表的结点数。12345678910111213141516LinkList Temp = L-&gt;next;int n = 0;while (Temp-&gt;next) &#123; Temp = Temp-&gt;next; n++;&#125;/*加一个条件判断。如果k大于n，即超出了链表结点数，查找就不可能成功。直接返回0退出函数即可。*/if (k &gt; n) &#123; return 0;&#125; 在这里，我们已知一共需要走count步，每走一步count减1，count为0时退出循环，Temp的指向恰好是我们寻找到的那个结点123456789// 用一个变量储存我们需要走的步数（从头结点开始）int count = n - k + 1;// 刚刚设置的临时指针更新到头结点处，准备开始遍历链表Temp = L;while (count) &#123; Temp = Temp-&gt;next; count--;&#125; 最后不要忘记赋值 p_ele 变量。12*p_ele = temp-&gt;data;return 1; 完整代码注意，完整代码在实现上稍微和前面的核心代码解释有出入，但运用的思想是完全相同的，不妨比较一下两者的差别在什么地方，此处差别有助于你理解 $n - k + 1$ 的本质。 1234567891011121314151617181920212223242526int lnk_search(LinkList L, int k, ElemType* p_ele) &#123; int n = 0; int count = 1; LinkList temp = L; while (temp-&gt;next != NULL) &#123; temp = temp-&gt;next; n++; &#125; if (k &gt; n) return 0; k = n - k + 1; temp = L-&gt;next; while (count != k) &#123; temp = temp-&gt;next; count ++; &#125; *p_ele = temp-&gt;data; return 1;&#125;","categories":["SISE","Icoding"]},{"path":"/2024/06/20/icoding-1-1/","content":"Icoding题解 线性表 合并题干链表 合并 设线性表A&#x3D;(a1, a2,…,am)，B&#x3D;(b1, b2,…,bn)，试写一个按下列规则合并A、B为线性表C的算法，使得：C&#x3D; (a1, b1,…,am, bm, bm+1, …,bn) 当m≤n时；或者C&#x3D; (a1, b1,…,an, bn, an+1, …,am) 当m&gt;n时。线性表A、B、C均以单链表作为存储结构，且C表利用A表和B表中的结点空间构成。注意：单链表的长度值m和n均未显式存储。函数的原型如下：void lnk_merge(LinkList A, LinkList B, LinkList C)即将A和B合并为C，其中 C 已经被初始化为空单链表相关定义如下： struct _lnklist{ ElemType data; struct _lnklist *next;}; typedef struct _lnklist Node;typedef struct _lnklist *LinkList; 分析 简要分析题干：题目的意思是，有链表A和链表B，A和B的结点数均未知，要求是将A和B合并为链表C。合并的要求是： 满足A链表中的结点和B链表中的结点交替连接 假如有一个链表的结点数过多，不满足交替连接，那么就直接将多余的部分接在合并的链表之后 要求用原来的结点合并链表，不要重新分配空间并复制原链表的数据 值得注意的问题： 交替连接链表 处理多余结点 使用原结点合并 链表有空的头结点 解题思路： 使用三个指针，一个指针跟踪A链表第一个未被合并到C的结点，一个指针跟踪B链表第一个未被合并到C的结点，还有一个跟踪新链表即C链表的最新结点。 使用一个循环，先连接A链表的一个结点，再连接B链表的一个结点。 处理A中多出来的结点，处理B中多出来的结点 核心代码 首先声明三个指针，分别代表指向A、B、C链表的指针这里需要注意，链表A，链表B均具有空的头节点123Node* CurrPtrC = C;Node* CurrPtrA = A-&gt;next;Node* CurrPtrB = B-&gt;next; 然后开始合并链表。一旦指向A的指针或指向B的指针中有一方为空，我们就知道，有一个链表走到了尽头。我们的循环要做的事情，就是保证A、B链表中的结点交替连接，直到一个链表的结点用完。循环进行条件：指向A链表节点和指向B链表节点的指针均不为空。 1234567891011121314while (CurrPtrA &amp;&amp; CurrPtrB) &#123; //将A的结点地址交给C指针的指向结点的next域 CurrPtrC-&gt;next = CurrPtrA; //此时A的结点地址已被保存，我们将A指针指向下一个A链表的结点 CurrPtrA = CurrPtrA-&gt;next; //然后，更新C指针，将其指向下一个结点 //用这种方式，我们可以保证C指针始终指向C链表最新的一个结点 CurrPtrC-&gt;next = CurrPtrC; //与上同理 CurrPtrB-&gt;next = CurrPtrB; CurrPtrB = CurrPtrB-&gt;next; CurrPtrC-&gt;next = CurrPtrC;&#125; 至此，我们在一次循环中，交替链接了A链表的一个结点、B链表的一个结点.同时，A指针指向A链表的下一个结点，B指针指向B链表的下一个结点.C指针指向最新的结点，也就是B链表中的一个结点.这样，我们每次循环都先后分别连接A、B两个链表中的一个结点. 然后，我们处理循环中没有处理完成的链表.如果A指针不为空，说明A链表有剩余结点.与前面的循环同理，不过除了笔者这种方法，也有更好的方法可以解决.比如说，一行 CurrPtrC-&gt;next = CurrPtrA 即可一劳永逸地解决，根本不需要循环.123456789101112while (CurrPtrA) &#123; CurrPtrC-&gt;next = CurrPtrA; CurrPtrA = CurrPtrA-&gt;next; CurrPtrC = CurrPtrC-&gt;next;&#125;//与上同理，如果B指针不为空，说明B链表有剩余结点while (CurrPtrB) &#123; CurrPtrC-&gt;next = CurrPtrB; CurrPtrB = CurrPtrB-&gt;next; CurrPtrC = CurrPtrC-&gt;next;&#125; 完整代码123456789101112131415161718192021222324252627282930void lnk_merge(LinkList A, LinkList B, LinkList C) &#123; Node* temp = C; Node* tempA = A-&gt;next; Node* tempB = B-&gt;next; while(tempA != NULL &amp;&amp; tempB != NULL) &#123; temp-&gt;next = tempA; temp = temp-&gt;next; tempA = tempA-&gt;next; temp-&gt;next = tempB; temp = temp-&gt;next; tempB = tempB-&gt;next; &#125; while (tempA != NULL) &#123; temp-&gt;next = tempA; temp = temp-&gt;next; tempA = tempA-&gt;next; &#125; while (tempB != NULL) &#123; temp-&gt;next = tempB; temp = temp-&gt;next; tempB = tempB-&gt;next; &#125; &#125;","categories":["SISE","Icoding"]},{"path":"/2024/05/09/hello-world/","content":"El Libro De Arena写在前面拾人牙慧总比自己苦思冥想金句来得轻松。我在此处引用一下上海交通大学生存手册的开头来作为我的开头。 各位同学们，在本书的开始，我不得不遗憾地告诉大家一个消息。国内绝大部分大学的本科教学，不是濒临崩溃，而是早已崩溃。在此，我无意争论是否复旦、中科大、或者清华、北大是否比我们崩溃的更少一些——这种争论是没有意义的。我只是看到了无数充满求知欲、激情、与年轻梦想的同学们，将要把自己的四年青春，充满希望与信任地交给大学来塑造。这使我心中非常不安。 你好，我该怎么做开场白才好？初次见面，还是…好久不见？ 关于网站在这里你可以找到一些有意思的东西，包括但不限于以下内容： 你如何在电子科大的信软学院生存下来 一些信软学院作业题解与资源 作者关于计算机技术与知识的个人见解（不一定正确） 一些技术博客 课程学习笔记，包括国外课程与国内课程 对于galgame的倾情推荐！！！偶尔会上传一些游玩感想 关于个人我是电子科技大学（University of Electronic and Science Technology of China）信息与软件工程学院的一名2023级学生。 从小到大就不会处理亲密关系，虽然本人很珍视任何一段人与人之间的联系，但几乎所有让我产生这样的情感的人几乎都曾责怪我与他们过于疏远。无怪乎我的家人曾痛斥：“你这个人太怪了，谁知道你在想什么！” 我渴望用尊重换取别人的不尊重，得到的是最开始的尊重、随之而来的小心翼翼与最终的指责。 人与人的关系处理不好的人，就会去喜欢别的东西，你大可以将其视作逃避，但你往往会听到那些人说：我有更重要的事情去做。但他们往往也不知道自己真实的想法是什么，人们常说抛出硬币时会知道自己想要的结果，然而象牙塔中的人一般未曾面临真正需要抛出硬币的抉择。 本人很喜欢Artificial Intelligence，尤其钟意NLP、多智能体以及和生成图像和视频的有关方向。希望能在该领域有所深耕吧。 可以通过weldaspica@outlook.com联系我，发邮件阐明来意就好，我会经常检查邮件。","categories":["杂言篇","迷路的序"]}]